<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Merge K Sorted Arrays — Min-Heap Visualizer</title>
<style>
  :root{
    --bg:#0f1220; --panel:#161a2d; --panel-2:#1e2340;
    --accent:#6cf3ff; --accent-2:#8ae9c1;
    --text:#ecf2ff; --muted:#a6b0cf;
    --slot:#2a305a; --chip:#39407a;
    --shadow:0 10px 30px rgba(0,0,0,.35);
    --radius:16px; --speed:300ms;
    --pair:#ffd166; --new:#8ae9c1; --bad:#b05a7a;
  }
  *{ box-sizing:border-box }
  body{
    margin:0; color:var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    background: radial-gradient(1000px 600px at 80% -10%, #1a1f3a 0%, #0f1220 50%) no-repeat, var(--bg);
  }
  header{
    padding:24px clamp(16px,4vw,32px);
    display:grid; grid-template-columns: 1fr auto; gap:16px; align-items:center;
  }
  h1{ margin:0; font-size: clamp(22px,2.2vw,30px) }
  .subtitle{ color:var(--muted); margin-top:6px; font-size:.95rem }
  .controls{ display:flex; gap:10px; flex-wrap:wrap; align-items:center }
  input,button{
    background: linear-gradient(180deg, var(--panel-2), var(--panel));
    color: var(--text); border:1px solid #222842; border-radius:10px;
    padding:10px 12px; font-weight:600; box-shadow:var(--shadow); cursor:pointer;
  }
  input[type="number"]{ width:90px }
  button:hover{ transform:translateY(-1px); border-color:#2c3256 }
  button[aria-pressed="true"]{ outline:2px solid var(--accent) }
  .chip{ background:var(--chip); color:var(--text); border:1px solid #2a2f58; padding:4px 8px; border-radius:999px; font-size:12px; font-weight:700 }

  main{
    padding:0 clamp(16px,4vw,32px) 32px;
    display:grid; grid-template-columns: 1.2fr .8fr; gap: clamp(14px, 2vw, 20px);
  }
  @media (max-width: 980px){ main{ grid-template-columns: 1fr } }

  .panel{
    background: linear-gradient(180deg, var(--panel-2), var(--panel));
    border:1px solid #20264a; border-radius: var(--radius); box-shadow: var(--shadow);
    overflow: clip;
  }
  .panel header{
    padding:12px 16px; background:#141832; border-bottom:1px solid #1f2546;
    display:flex; justify-content: space-between; align-items:center;
  }
  .panel header h2{ margin:0; font-size:16px }
  .panel .content{ padding:18px }

  /* Arrays list */
  .arrays{ display:grid; gap:16px }
  .row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:8px }
  .lbl{ padding:8px 14px; border-radius:999px; background:var(--chip); border:1px solid #2a2f58; font-weight:700; font-size:13px; min-width:50px; text-align:center }
  .arr{ display:flex; gap:10px; flex-wrap:wrap; align-items:center }
  .cell{
    padding:12px 16px; border-radius:10px; background:var(--slot); border:1px solid #2a2f58;
    font-weight:800; min-width:50px; text-align:center; transition:all var(--speed);
    font-size:14px;
  }
  .cell.ptr{ outline:2px solid var(--pair) }
  .cell.done{ opacity:.5 }

  .btn-sm{ padding:8px 10px }

  /* Result */
  .result{ display:flex; gap:12px; flex-wrap:wrap; align-items:center }
  .rescell{ padding:12px 16px; border-radius:10px; background:#1f2c2a; border:1px solid #2a4a3f; font-weight:800; font-size:14px }

  /* Heap area */
  .heap-array{ display:flex; gap:10px; flex-wrap:wrap }
  .hcell{
    padding:12px 16px; border-radius:10px; background:var(--slot); border:1px solid #2a2f58;
    font-weight:800; min-width:120px; text-align:center; transition:all var(--speed);
    font-size:13px; line-height:1.3;
  }
  .hcell.top{ outline:2px solid var(--new) }

  svg{ width:100%; height:100%; display:block }
  .edge{ stroke:#6f78b8; stroke-width:3 }
  .node circle{ r:32; fill:#1d2350; stroke:#2e3a7d; stroke-width:2 }
  .node text{ fill:var(--text); font-weight:700; font-size:13px; text-anchor:middle; dominant-baseline:middle }
  .node .value{ font-size:18px; font-weight:800; fill:var(--accent) }
  .node .meta{ font-size:12px; fill:var(--muted) }
  .node.top circle{ stroke: var(--new); stroke-width:3 }

  .explain{ background:#101433; border-top:1px solid #1f2546; padding:12px 14px }
  .explain b{ color: var(--accent) }
  .kbd{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas; background:#0e1230; border:1px solid #1c2250; padding:2px 6px; border-radius:8px }
</style>
</head>
<body>
  <header>
    <div>
      <h1>🧮 Merge K Sorted Arrays — Min-Heap</h1>
      <div class="subtitle">Always extract the <b>minimum</b> and push the next element from the same array. Time: <span class="chip">O(N log K)</span></div>
    </div>
    <div class="controls">
      <button id="btn-add" class="btn-sm">+ Add Array</button>
      <button id="btn-rem" class="btn-sm">− Remove Last</button>
      <label class="chip" for="len">Rand len≤</label>
      <input id="len" type="number" value="6" min="1"/>
      <button id="btn-rand" class="btn-sm">Randomize 🎲</button>
      <button id="btn-set" class="btn-sm">Apply Inputs</button>
      <button id="btn-play">▶ Play</button>
      <button id="btn-step">Step ▷</button>
      <button id="btn-reset">Reset ↺</button>
    </div>
  </header>

  <main>
    <section class="panel">
      <header>
        <h2>Input Arrays</h2>
        <div class="chip" id="status">Status: Ready</div>
      </header>
      <div class="content">
        <div id="inputArea"></div>
        <div class="arrays" id="arrays"></div>
      </div>

      <div class="explain" id="explain">
        Initialize the heap with the first element of each array as tuples <code>(value, arrIndex, elemIndex)</code>.
        Then repeatedly pop the smallest, append to result, and push the next from that array.
      </div>

      <div class="content">
        <div class="row">
          <span class="lbl">Result</span>
          <div id="result" class="result"></div>
        </div>
      </div>
    </section>

    <section class="panel">
      <header>
        <h2>Min-Heap (tuples)</h2>
        <div class="chip" id="heap-info">—</div>
      </header>
      <div class="content">
        <div id="heapArray" class="heap-array"></div>
        <div style="height:450px;margin-top:10px">
          <svg id="heapTree" viewBox="0 0 1000 400"></svg>
        </div>
      </div>
    </section>
  </main>

<script type="module">
/* Elements */
const btnAdd  = document.getElementById('btn-add');
const btnRem  = document.getElementById('btn-rem');
const btnRand = document.getElementById('btn-rand');
const btnSet  = document.getElementById('btn-set');
const btnPlay = document.getElementById('btn-play');
const btnStep = document.getElementById('btn-step');
const btnReset= document.getElementById('btn-reset');

const lenInput= document.getElementById('len');
const inputArea = document.getElementById('inputArea');
const arraysEl  = document.getElementById('arrays');
const resultEl  = document.getElementById('result');

const heapArray = document.getElementById('heapArray');
const heapTree  = document.getElementById('heapTree');
const heapInfo  = document.getElementById('heap-info');

const statusEl  = document.getElementById('status');
const explainEl = document.getElementById('explain');

/* State */
const STATE = {
  inputs: [ "1,4,5", "1,3,4", "2,6" ],
  arrays: [],     // parsed arrays
  ptrs: [],       // current element index per array
  heap: [],       // tuples {v, ai, ei, tiebreak}
  res: [],
  running: false,
  timer: null,
  tiebreak: 0,    // to stabilize tuples with equal values
};

/* Utils */
function parseLine(s){
  return s.split(',').map(x=>x.trim()).filter(Boolean).map(Number).filter(v=>!Number.isNaN(v));
}
function say(html){ explainEl.innerHTML = html; }
function setStatus(t){ statusEl.textContent = `Status: ${t}`; }

/* Min-heap over tuple (v, ai, ei, tiebreak) */
function less(a,b){
  if (a.v !== b.v) return a.v < b.v;
  if (a.ai !== b.ai) return a.ai < b.ai;
  if (a.ei !== b.ei) return a.ei < b.ei;
  return a.tiebreak < b.tiebreak;
}
function siftUp(i){
  while(i>0){
    const p=(i-1)>>1;
    if (less(STATE.heap[i], STATE.heap[p])){ [STATE.heap[i],STATE.heap[p]]=[STATE.heap[p],STATE.heap[i]]; i=p; }
    else break;
  }
}
function siftDown(i){
  const n=STATE.heap.length;
  while(true){
    const l=2*i+1, r=2*i+2;
    let best=i;
    if (l<n && less(STATE.heap[l], STATE.heap[best])) best=l;
    if (r<n && less(STATE.heap[r], STATE.heap[best])) best=r;
    if (best!==i){ [STATE.heap[i],STATE.heap[best]]=[STATE.heap[best],STATE.heap[i]]; i=best; }
    else break;
  }
}
function heapPush(t){ STATE.heap.push(t); siftUp(STATE.heap.length-1); }
function heapPop(){
  if (!STATE.heap.length) return null;
  const n=STATE.heap.length;
  const root=STATE.heap[0];
  const last=STATE.heap.pop();
  if(n>1){ STATE.heap[0]=last; siftDown(0); }
  return root;
}

/* Rendering */
function renderInputEditors(){
  inputArea.innerHTML = '';
  const wrap = document.createElement('div');
  wrap.style.display='grid'; wrap.style.gap='8px';
  STATE.inputs.forEach((s, idx)=>{
    const row=document.createElement('div');
    row.className='row';
    row.innerHTML = `<span class="lbl">A${idx}</span>`;
    const inp=document.createElement('input');
    inp.value = s; inp.style.minWidth='360px';
    inp.addEventListener('change',()=>{ STATE.inputs[idx]=inp.value; });
    row.appendChild(inp);
    inputArea.appendChild(row);
  });
}

function renderArrays(){
  arraysEl.innerHTML = '';
  STATE.arrays.forEach((arr, ai)=>{
    const row=document.createElement('div'); row.className='row';
    const lab=document.createElement('span'); lab.className='lbl'; lab.textContent=`A${ai}`;
    row.appendChild(lab);
    const div=document.createElement('div'); div.className='arr';
    arr.forEach((v, ei)=>{
      const c=document.createElement('div');
      let cls='cell';
      if (STATE.ptrs[ai]===ei) cls+=' ptr';
      if (ei<STATE.ptrs[ai]) cls+=' done';
      c.className=cls; c.textContent=v; div.appendChild(c);
    });
    row.appendChild(div);
    arraysEl.appendChild(row);
  });
}

function renderResult(){
  resultEl.innerHTML='';
  STATE.res.forEach(v=>{
    const d=document.createElement('div'); d.className='rescell'; d.textContent=v; resultEl.appendChild(d);
  });
}

function renderHeap(){
  // array
  heapArray.innerHTML='';
  STATE.heap.forEach((t, idx)=>{
    const d=document.createElement('div');
    let cls='hcell'; if(idx===0) cls+=' top';
    d.className=cls;
    d.textContent = `(${t.v}, A${t.ai}, i=${t.ei})`;
    heapArray.appendChild(d);
  });
  heapInfo.textContent = `size=${STATE.heap.length}`;

  // tree
  heapTree.innerHTML='';
  const n=STATE.heap.length; if(!n) return;
  const levels = Math.floor(Math.log2(n)) + 1;
  const width=1000, height=400;
  const nodes=[];
  for(let i=0;i<n;i++){
    const level=Math.floor(Math.log2(i+1));
    const pos=i-(2**level-1);
    const cnt=2**level;
    const x=(width/(cnt+1))*(pos+1), y=(height/(levels+1))*(level+1);
    nodes.push({i,x,y,value:STATE.heap[i].v,array:STATE.heap[i].ai,index:STATE.heap[i].ei});
  }
  nodes.forEach(nd=>{
    const l=2*nd.i+1, r=2*nd.i+2;
    if(l<nodes.length){
      const line=document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1',nd.x); line.setAttribute('y1',nd.y);
      line.setAttribute('x2',nodes[l].x); line.setAttribute('y2',nodes[l].y);
      line.setAttribute('class','edge'); heapTree.appendChild(line);
    }
    if(r<nodes.length){
      const line=document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1',nd.x); line.setAttribute('y1',nd.y);
      line.setAttribute('x2',nodes[r].x); line.setAttribute('y2',nodes[r].y);
      line.setAttribute('class','edge'); heapTree.appendChild(line);
    }
  });
  nodes.forEach(nd=>{
    const g=document.createElementNS('http://www.w3.org/2000/svg','g');
    let cls='node'; if(nd.i===0) cls+=' top';
    g.setAttribute('class',cls);
    g.setAttribute('transform',`translate(${nd.x},${nd.y})`);
    g.innerHTML = `<circle></circle><text class="value" dy="-6">${nd.value}</text><text class="meta" dy="8">A${nd.array},i=${nd.index}</text>`;
    heapTree.appendChild(g);
  });
}

/* Core algorithm steps */
function seedHeap(){
  STATE.heap = [];
  STATE.ptrs = STATE.arrays.map(_=>0);
  for(let ai=0; ai<STATE.arrays.length; ai++){
    const arr = STATE.arrays[ai];
    if (arr.length>0){
      heapPush({ v: arr[0], ai, ei: 0, tiebreak: STATE.tiebreak++ });
    }
  }
  renderArrays(); renderHeap();
  say(`Seeded heap with first element from each non-empty array.`);
  setStatus('Seeded');
}

function step(){
  // If heap empty → done
  if (STATE.heap.length===0){
    setStatus('Done'); say('<b>All arrays exhausted.</b> Merge complete.');
    return false;
  }

  // Extract-min
  const t = heapPop();
  STATE.res.push(t.v);
  renderResult(); renderHeap();
  setStatus(`Popped min (${t.v}) from A${t.ai} @ i=${t.ei}`);

  // Advance pointer in its array and push next if exists
  const nextEi = t.ei + 1;
  STATE.ptrs[t.ai] = nextEi;
  const arr = STATE.arrays[t.ai];

  renderArrays();

  if (nextEi < arr.length){
    heapPush({ v: arr[nextEi], ai: t.ai, ei: nextEi, tiebreak: STATE.tiebreak++ });
    renderHeap();
    say(`Appended ${t.v} to result. Pushed next (${arr[nextEi]}) from A${t.ai}.`);
  } else {
    say(`Appended ${t.v} to result. A${t.ai} is now exhausted.`);
  }

  return true;
}

/* Controls */
function play(){
  if (STATE.running){
    STATE.running=false; btnPlay.textContent='▶ Play'; btnPlay.setAttribute('aria-pressed','false');
    clearTimeout(STATE.timer); return;
  }
  STATE.running=true; btnPlay.textContent='⏸ Pause'; btnPlay.setAttribute('aria-pressed','true');
  const tick=()=>{
    if(!STATE.running) return;
    const more = step();
    if(!more){ STATE.running=false; btnPlay.textContent='▶ Play'; btnPlay.setAttribute('aria-pressed','false'); return; }
    STATE.timer = setTimeout(tick, 800);
  };
  tick();
}

function applyInputs(){
  // read editors into arrays
  STATE.arrays = STATE.inputs.map(parseLine);
  // ensure each is sorted (for safety/teaching)
  STATE.arrays = STATE.arrays.map(a => a.slice().sort((x,y)=>x-y));
  STATE.res = [];
  STATE.tiebreak = 0;
  seedHeap();
}

function addArray(){
  STATE.inputs.push("1,2,3");
  renderInputEditors();
}
function removeArray(){
  if (STATE.inputs.length>0) STATE.inputs.pop();
  renderInputEditors();
}
function randomize(){
  const k = Math.max(2, Math.min(8, STATE.inputs.length || 3));
  const maxLen = Math.max(1, Math.min(20, Number(lenInput.value)||6));
  STATE.inputs = Array.from({length:k}, ()=>{
    const len = 1 + Math.floor(Math.random()*maxLen);
    const arr = Array.from({length:len}, ()=> Math.floor(Math.random()*40));
    arr.sort((a,b)=>a-b);
    return arr.join(',');
  });
  renderInputEditors();
}

function resetAll(){
  clearTimeout(STATE.timer); STATE.running=false; btnPlay.textContent='▶ Play'; btnPlay.setAttribute('aria-pressed','false');
  STATE.res = []; STATE.heap = []; STATE.tiebreak=0;
  renderInputEditors();
  applyInputs();
  setStatus('Ready');
}

/* Wire up */
btnAdd.addEventListener('click', addArray);
btnRem.addEventListener('click', removeArray);
btnRand.addEventListener('click', randomize);
btnSet.addEventListener('click', applyInputs);
btnPlay.addEventListener('click', play);
btnStep.addEventListener('click', ()=>{ if(STATE.running) play(); step(); });
btnReset.addEventListener('click', resetAll);

window.addEventListener('keydown', (e)=>{
  if (e.key === ' '){ e.preventDefault(); play(); }
  if (e.key.toLowerCase()==='n'){ if(STATE.running) play(); step(); }
  if (e.key.toLowerCase()==='r'){ resetAll(); }
});

/* Bootstrap */
renderInputEditors();
applyInputs();

/* Reference
function mergeKSorted(arrays):
  minHeap of (value, arrayIndex, elementIndex)
  push first element of each array
  while heap not empty:
    t = pop min
    result.push(t.value)
    if next exists in same array:
      push(next)
  return result
*/
</script>
</body>
</html>
