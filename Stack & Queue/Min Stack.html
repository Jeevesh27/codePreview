<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Min Stack Visualizer â€” O(1) getMin</title>
<style>
  :root{
    --bg:#0f1220; --panel:#161a2d; --panel-2:#1e2340;
    --accent:#6cf3ff; --accent-2:#8ae9c1;
    --text:#ecf2ff; --muted:#a6b0cf;
    --ok:#84fab0; --slot:#2a305a; --chip:#39407a;
    --shadow:0 10px 30px rgba(0,0,0,.35);
    --radius:16px; --gap:14px; --speed:300ms;
    --pair:#ffd166; /* yellow for selected terms */
    --new:#8ae9c1;  /* green for newly added term */
  }

  /* Layout */
  body { margin:0; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }
  .wrap { max-width:1100px; margin:40px auto; padding:0 18px; display:grid; gap:var(--gap); }
  header { display:flex; flex-wrap:wrap; gap:var(--gap); align-items:center; justify-content:space-between; }
  h1 { font-size:clamp(20px, 2.4vw, 28px); margin:0; letter-spacing:.3px; }
  .subtitle { color:var(--muted); font-size:14px; margin-top:4px; }

  /* Panels */
  .panel { background:linear-gradient(180deg, var(--panel), var(--panel-2)); border-radius:var(--radius); box-shadow:var(--shadow); padding:16px; }
  .controls { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
  .controls input[type="number"]{
    background:var(--slot); border:1px solid transparent; outline:none; color:var(--text);
    border-radius:12px; padding:12px 14px; width:120px; font-size:15px; transition:border .2s ease;
  }
  .controls input[type="number"]:focus{ border-color:var(--accent); }
  .btn{
    appearance:none; border:none; border-radius:12px; padding:12px 14px; font-weight:600; letter-spacing:.2px;
    background:var(--chip); color:var(--text); cursor:pointer; transition:transform .06s ease, filter .2s ease, background .2s ease;
  }
  .btn:hover{ filter:brightness(1.06); }
  .btn:active{ transform:translateY(1px) scale(.995); }
  .btn.primary{ background:linear-gradient(180deg, var(--accent), var(--accent-2)); color:#0b1220; }
  .btn.warning{ background:linear-gradient(180deg, #ff8a8a, #ffa3a3); color:#230000; }
  .btn.outline{ background:transparent; border:1px solid var(--chip); }
  .btn.small{ padding:8px 10px; font-size:13px; }

  /* Columns */
  .cols { display:grid; grid-template-columns: 1fr 1fr; gap:var(--gap); }
  @media (max-width: 820px){ .cols { grid-template-columns: 1fr; } }

  .col h3{ margin:0 0 10px; font-size:16px; font-weight:700; display:flex; align-items:center; gap:8px; }
  .legend { margin-left:auto; display:flex; gap:10px; }
  .tag{ display:inline-flex; align-items:center; gap:6px; font-size:12px; color:var(--muted); padding:2px 8px; border-radius:999px; background:rgba(255,255,255,.06); }
  .swatch{ width:10px; height:10px; border-radius:2px; background:var(--pair); }
  .swatch.new{ background:var(--new); }
  .swatch.min{ background:var(--ok); }

  /* Stack visuals */
  .stack {
    position:relative;
    min-height:260px;
    display:flex;
    flex-direction:column-reverse; /* bottom grows upward */
    gap:10px;
    border-radius:12px;
    background:radial-gradient(1200px 300px at 50% 120%, rgba(255,255,255,.03), transparent 60%), var(--slot);
    padding:16px;
    overflow:hidden;
    outline:1px solid rgba(255,255,255,.06);
  }
  .stack::before{
    content:"top â†’"; position:absolute; top:10px; right:12px; color:var(--muted); font-size:12px; letter-spacing:.3px;
  }
  .node {
    align-self:flex-start;
    display:inline-flex; align-items:center; justify-content:center;
    min-width:56px; height:40px; padding:0 14px;
    background:var(--chip); border-radius:10px; font-weight:700; letter-spacing:.4px;
    box-shadow:0 6px 18px rgba(0,0,0,.30); border:1px solid rgba(255,255,255,.07);
    transform-origin:center; opacity:0; transform:translateY(12px) scale(.96);
    transition:opacity var(--speed) ease, transform var(--speed) ease, border-color var(--speed) ease, background var(--speed) ease;
  }
  .node.show{ opacity:1; transform:translateY(0) scale(1); }
  .node.new { outline:2px solid var(--new); background:linear-gradient(180deg, rgba(138,233,193,.25), var(--chip)); }
  .node.pair{ outline:2px dashed var(--pair); }
  .node.minMark{ outline:2px solid var(--ok); }

  /* status + history */
  .status {
    display:flex; gap:10px; align-items:center; color:var(--muted); font-size:14px;
  }
  .status strong { color:var(--text); }
  .toast { margin-left:auto; background:rgba(255,255,255,.04); padding:8px 10px; border-radius:10px; color:var(--muted); font-size:13px; }
  .history { margin-top:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12.5px; color:var(--muted); line-height:1.5; max-height:130px; overflow:auto; background:rgba(255,255,255,.04); padding:10px 12px; border-radius:10px; }

  /* helper badges */
  .badge { font-size:11px; color:var(--bg); background:var(--accent); padding:4px 8px; border-radius:999px; font-weight:800; letter-spacing:.4px; }
  .note { color:var(--muted); font-size:13px; }

  /* link */
  a { color:var(--accent); text-decoration:none; }
  a:hover { text-decoration:underline; }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>ðŸ“‰ Min Stack Visualizer <span class="badge">O(1) getMin</span></h1>
        <div class="subtitle">Two stacks: <strong>Main</strong> holds all items, <strong>Min</strong> tracks the running minimum. On <code>push(x)</code>, push <code>x</code> to Main and <code>min(x, currentMin)</code> to Min. On <code>pop()</code>, pop both.</div>
      </div>
      <div class="controls panel">
        <input id="val" type="number" placeholder="Value e.g. 7" />
        <button class="btn primary" id="pushBtn">Push</button>
        <button class="btn" id="popBtn">Pop</button>
        <button class="btn" id="minBtn">getMin()</button>
        <button class="btn outline" id="randomBtn" title="Push a random value">+ Random</button>
        <button class="btn warning" id="resetBtn" title="Clear stacks">Reset</button>
      </div>
    </header>

    <section class="cols">
      <div class="col panel">
        <h3>Main Stack
          <span class="legend">
            <span class="tag"><span class="swatch new"></span>new</span>
            <span class="tag"><span class="swatch"></span>paired</span>
          </span>
        </h3>
        <div id="mainStack" class="stack" aria-live="polite"></div>
      </div>

      <div class="col panel">
        <h3>Min Stack
          <span class="legend">
            <span class="tag"><span class="swatch min"></span>min</span>
          </span>
        </h3>
        <div id="minStack" class="stack" aria-live="polite"></div>
      </div>
    </section>

    <section class="panel">
      <div class="status">
        <div>Size: <strong><span id="size">0</span></strong></div>
        <div>Current Min: <strong id="curMin">â€”</strong></div>
        <div class="toast" id="toast">Ready.</div>
      </div>
      <div class="history" id="history"></div>
      <div class="note" style="margin-top:10px">
        Tip: Try pushing a few numbers (including negatives). Notice how the Min Stack mirrors the <em>running</em> minimum. Because we update both stacks in lockstep, <code>getMin()</code> is just peeking the top of the Min Stack â†’ O(1).
      </div>
    </section>
  </div>

<script>
(() => {
  // === Model ===
  const main = [];
  const mins  = [];

  // === DOM ===
  const el = (q) => document.querySelector(q);
  const mainStackEl = el('#mainStack');
  const minStackEl  = el('#minStack');
  const sizeEl      = el('#size');
  const curMinEl    = el('#curMin');
  const toastEl     = el('#toast');
  const historyEl   = el('#history');
  const valInput    = el('#val');

  // Buttons
  el('#pushBtn').addEventListener('click', () => {
    const v = Number(valInput.value);
    if (Number.isNaN(v)) return notify('Enter a number to push.');
    push(v, { highlight:true });
    valInput.value = '';
    valInput.focus();
  });
  el('#popBtn').addEventListener('click', () => pop({ highlight:true }));
  el('#minBtn').addEventListener('click', () => peekMin({ announce:true }));
  el('#resetBtn').addEventListener('click', resetAll);
  el('#randomBtn').addEventListener('click', () => {
    const r = Math.floor(Math.random() * 199) - 99; // -99..99
    push(r, { highlight:true });
  });

  // Enter to push
  valInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') el('#pushBtn').click();
  });

  // === Stack operations ===
  function push(x, opts = {}) {
    main.push(x);
    const newMin = mins.length ? Math.min(x, mins[mins.length-1]) : x;
    mins.push(newMin);
    log(`push(${x}) â†’ min=${newMin}`);
    render({ newIndex: main.length - 1, pair: true, ...opts });
    notify(`Pushed ${x}.`);
  }

  function pop(opts = {}) {
    if (!main.length) {
      notify('Stack is empty. Nothing to pop.');
      return;
    }
    const v = main.pop();
    const m = mins.pop();
    log(`pop() â†’ ${v} (min was ${m})`);
    render({ popped:true, ...opts });
    notify(`Popped ${v}.`);
  }

  function peekMin({ announce=false } = {}) {
    if (!mins.length) {
      if (announce) notify('No minimum (stack is empty).');
      return null;
    }
    const m = mins[mins.length - 1];
    if (announce) {
      blinkTop(minStackEl);
      notify(`getMin() = ${m}`);
    }
    return m;
  }

  function resetAll() {
    main.length = 0; mins.length = 0;
    render();
    historyEl.textContent = '';
    notify('Stacks cleared.');
  }

  // === Rendering ===
  function render({ newIndex = null, popped = false, pair = false, highlight = false } = {}) {
    // Clear visuals
    mainStackEl.innerHTML = '';
    minStackEl.innerHTML  = '';

    // Rebuild nodes (bottom to top visual via flex column-reverse)
    main.forEach((v, i) => {
      const node = makeNode(v);
      if (highlight && i === newIndex) { node.classList.add('new'); requestAnimationFrame(() => node.classList.add('show')); }
      else { requestAnimationFrame(() => node.classList.add('show')); }
      mainStackEl.appendChild(node);
    });

    mins.forEach((v, i) => {
      const node = makeNode(v);
      node.classList.add('minMark');
      if (highlight && i === newIndex) node.classList.add('new');
      requestAnimationFrame(() => node.classList.add('show'));
      minStackEl.appendChild(node);
    });

    // Pair highlight between the two stacks for the top item
    if (pair && main.length) {
      const lastMainNode = mainStackEl.children[mainStackEl.children.length - 1];
      const lastMinNode  = minStackEl.children[minStackEl.children.length - 1];
      [lastMainNode, lastMinNode].forEach(n => n && n.classList.add('pair'));
      // remove pair highlight after a beat
      setTimeout(() => [lastMainNode, lastMinNode].forEach(n => n && n.classList.remove('pair')), 600);
    }

    sizeEl.textContent = main.length;
    curMinEl.textContent = mins.length ? mins[mins.length - 1] : 'â€”';

    // If a pop happened, blink the "top" area for feedback
    if (popped) { blinkTop(mainStackEl); blinkTop(minStackEl); }
  }

  function makeNode(text) {
    const div = document.createElement('div');
    div.className = 'node';
    div.textContent = text;
    return div;
  }

  function blinkTop(stackEl) {
    stackEl.animate([{ filter:'brightness(1.2)' }, { filter:'brightness(1)' }], { duration: 350, easing: 'ease-out' });
  }

  // === UX helpers ===
  function notify(msg) {
    toastEl.textContent = msg;
    toastEl.animate([{ opacity:.65 }, { opacity:1 }], { duration:200, easing:'ease-out' });
  }

  function log(line) {
    const t = new Date();
    const ts = t.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});
    historyEl.textContent += `[${ts}] ${line}\n`;
    historyEl.scrollTop = historyEl.scrollHeight;
  }

  // Seed a tiny demo so itâ€™s not empty on load
  const seed = [5, 3, 7, 2];
  let i = 0;
  const seedTimer = setInterval(() => {
    if (i >= seed.length) return clearInterval(seedTimer);
    push(seed[i++], { highlight:true, pair:true });
  }, 280);

})();
</script>
</body>
</html>
