<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Bellman–Ford Visualizer</title>
<style>
  :root{
    --bg:#0f1220; --panel:#161a2d; --panel-2:#1e2340;
    --accent:#6cf3ff; --accent-2:#8ae9c1;
    --text:#ecf2ff; --muted:#a6b0cf;
    --ok:#84fab0; --slot:#2a305a; --chip:#39407a;
    --shadow:0 10px 30px rgba(0,0,0,.35);
    --radius:16px; --gap:14px; --speed:300ms;
    --pair:#ffd166; --new:#8ae9c1;
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:radial-gradient(1200px 800px at 20% 10%, #151935 0%, var(--bg) 55%);color:var(--text);font:15px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}

  .app{max-width:1200px;margin:24px auto;padding:0 var(--gap);display:grid;grid-template-columns:1.25fr 1fr;grid-template-rows:auto auto 1fr auto;gap:var(--gap)}
  .title{grid-column:1/-1;display:flex;align-items:center;gap:12px}
  .controls-section{grid-column:1/-1}
  .edges-section{grid-column:1/-1}
  .graph-section{grid-column:1}
  .code-section{grid-column:2}
  .distances-section{grid-column:1/-1}
  h1{font-size:22px;margin:0;letter-spacing:.3px}
  .badge{padding:4px 10px;border-radius:999px;background:linear-gradient(145deg,var(--panel-2),var(--panel));border:1px solid #2a2f59;color:var(--accent);font-weight:600;box-shadow:var(--shadow)}

  .card{background:linear-gradient(180deg,var(--panel),var(--panel-2));border:1px solid #2a2f59;border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden}
  .card h2{margin:0;padding:14px 16px 0;font-size:15px;color:var(--muted);letter-spacing:.4px}
  .card .content{padding:14px 16px 16px}

  .graph-wrap{position:relative;aspect-ratio:16/10;min-height:360px;overflow:hidden}
  svg{width:100%;height:100%;display:block;background:
      radial-gradient(600px 400px at 90% -10%, rgba(108,243,255,.08) 0%, rgba(108,243,255,0) 70%),
      linear-gradient(0deg, rgba(255,255,255,0.03), rgba(255,255,255,0.03));
  }

  /* Arrow markers */
  .arrow{fill:#4c5286}
  .edge{stroke:#4c5286;stroke-width:2.5;opacity:.95;transition:stroke var(--speed),opacity var(--speed)}
  .edge.active{stroke:var(--pair)}
  .edge.tree{stroke:var(--ok)}
  .edge.bad{stroke:#ff8080}
  .wlabel{fill:var(--muted);font-weight:700;font-size:12px;user-select:none}
  .wlabel.active{fill:var(--pair)}
  .wlabel.tree{fill:var(--ok)}
  .wlabel.bad{fill:#ff9c9c}

  .node{cursor:pointer;transition:transform var(--speed)}
  .node circle{fill:var(--slot);stroke:#2f3566;stroke-width:2;filter:drop-shadow(0 6px 10px rgba(0,0,0,.35));transition:fill var(--speed),stroke var(--speed),r var(--speed)}
  .node text{fill:var(--text);font-weight:700;pointer-events:none}
  .node:hover{transform:translateY(-2px)}
  .node.source circle{stroke:var(--pair)}
  .node.updated circle{stroke:var(--new)}
  .node.final circle{stroke:var(--ok)}
  .node.bad circle{stroke:#ff8080}

  /* Right column */
  .controls{display:grid;gap:var(--gap)}
  .btnbar{display:grid;grid-template-columns:repeat(5,minmax(0,1fr));gap:10px}
  button,.select,input[type="range"]{
    background:linear-gradient(180deg,var(--panel-2),var(--panel));
    border:1px solid #2a2f59;border-radius:12px;color:var(--text);
    padding:10px 12px;font-weight:600;letter-spacing:.3px;box-shadow:var(--shadow)
  }
  button{cursor:pointer;transition:transform var(--speed),opacity var(--speed)}
  button:hover{transform:translateY(-2px)}
  button[disabled]{opacity:.45;cursor:not-allowed;transform:none}
  .select{display:flex;align-items:center;justify-content:space-between;padding-right:10px}
  select{width:100%;background:transparent;border:none;color:var(--text);font-weight:700;outline:none;appearance:none;cursor:pointer}

  .edges,.dist{display:flex;gap:10px;align-items:center;flex-wrap:wrap;min-height:52px}
  .chip{background:linear-gradient(180deg,var(--chip),#2f376e);border:1px solid #50589a;color:var(--text);border-radius:10px;padding:8px 10px;font-weight:700;min-width:42px;text-align:center;box-shadow:var(--shadow)}
  .chip.active{outline:2px solid var(--pair)}
  .chip.upd{outline:2px solid var(--new)}
  .chip.bad{outline:2px solid #ff8080}

  .kv{display:grid;grid-template-columns:auto auto;gap:6px 10px}
  .kv div{padding:6px 8px;border:1px solid #2a2f59;border-radius:8px;background:linear-gradient(180deg,var(--panel-2),var(--panel));font-weight:700}
  .kv .key{color:var(--muted);font-weight:600}
  .kv .val.inf{opacity:.7}
  .kv .val.upd{outline:2px solid var(--new)}

  .legend{display:grid;grid-template-columns:repeat(4,auto);gap:10px 14px;align-items:center;padding:12px 16px 16px;border-top:1px solid #2a2f59;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0))}
  .legend .dot{width:12px;height:12px;border-radius:50%;border:2px solid transparent;display:inline-block;margin-right:6px}
  .l-src .dot{border-color:var(--pair);background:var(--slot)}
  .l-upd .dot{border-color:var(--new);background:var(--slot)}
  .l-tree .dot{border-color:var(--ok);background:#1e304b}
  .l-neg .dot{border-color:#ff8080;background:#3b1e28}

  pre.code{background:#0f1433;border:1px solid #2a2f59;border-radius:12px;padding:12px;margin:0;overflow:auto;line-height:1.45;font-size:13px;counter-reset:ln}
  pre.code code{white-space:pre;display:block}
  .ln{display:block;padding-left:34px;position:relative}
  .ln::before{counter-increment:ln;content:counter(ln);position:absolute;left:8px;color:#5b6298}
  .hl{background:linear-gradient(90deg,rgba(255,209,102,.18),transparent 60%)}

  .banner{display:none;margin-top:8px;padding:10px 12px;border-radius:10px;border:1px solid #6b2b2b;background:linear-gradient(180deg,#3a1a1a,#2a1010);color:#ffbdbd;font-weight:700}
  .banner.show{display:block}
  .note{color:var(--muted);margin-top:6px}

  @media (max-width:980px){
    .app{grid-template-columns:1fr;grid-template-rows:auto auto auto auto auto auto}
    .controls-section,.edges-section,.graph-section,.code-section,.distances-section{grid-column:1}
  }
</style>
</head>
<body>
<div class="app" aria-live="polite">
  <div class="title">
    <span class="badge">Graph Algorithms</span>
    <h1>Bellman–Ford Algorithm</h1>
  </div>

  <!-- Controls section -->
  <section class="card controls-section">
    <h2>Controls</h2>
    <div class="content">
      <div class="btnbar" role="group" aria-label="Controls">
        <button id="btnPlay" title="Play / Pause (Space)">▶ Play</button>
        <button id="btnStep" title="Step (N)">Step</button>
        <button id="btnReset" title="Reset (R)">Reset</button>
        <div class="select" title="Choose source">
          <select id="sourceSel" aria-label="Source node"></select>
        </div>
        <button id="btnShuffle" title="Shuffle layout">Shuffle</button>
      </div>
      <div class="btnbar" style="margin-top:10px;grid-template-columns:repeat(3,minmax(0,1fr))">
        <button id="btnLoadBase" title="Load default graph (no negative cycle)">Load Base Graph</button>
        <button id="btnLoadNeg" title="Load graph with a negative cycle">Load Negative Cycle</button>
        <button id="btnShowPath" title="Highlight path to last updated / max finite">Show Path</button>
      </div>
      <div class="range-row" style="margin-top:12px">
        <div>
          <label for="speed">Speed</label>
          <input id="speed" type="range" min="0.2" max="2.5" step="0.1" value="1"/>
        </div>
        <div class="speed-val"><span id="speedVal">1.0</span>×</div>
      </div>
      <div id="banner" class="banner">⚠ Negative weight cycle detected! Distances can decrease forever.</div>
    </div>
  </section>

  <!-- Edges section -->
  <section class="card edges-section">
    <h2>Edges (relaxation order)</h2>
    <div class="content">
      <div id="edgesBar" class="edges" aria-live="polite"></div>
    </div>
  </section>

  <!-- Graph section -->
  <section class="card graph-section">
    <h2>Directed Weighted Graph</h2>
    <div class="content">
      <div class="graph-wrap" id="graphWrap" role="region" aria-label="Graph canvas. Click a node to set source.">
        <svg id="graph" viewBox="0 0 800 520"></svg>
      </div>
      <div class="legend">
        <div class="l-src"><span class="dot"></span>Source</div>
        <div class="l-upd"><span class="dot"></span>Distance updated</div>
        <div class="l-tree"><span class="dot"></span>Tree edge (predecessor)</div>
        <div class="l-neg"><span class="dot"></span>Negative cycle edge</div>
      </div>
    </div>
  </section>

  <!-- Code section -->
  <section class="card code-section">
    <h2>Pseudocode</h2>
    <div class="content">
<pre class="code" aria-label="Bellman-Ford pseudocode">
<code id="code">
<span class="ln" data-ln="1">function <b>BellmanFord</b>(V, edges, <span style="color:var(--pair)">source</span>):</span>
<span class="ln" data-ln="2">    dist = array of size V initialized to ∞</span>
<span class="ln" data-ln="3">    dist[source] = 0</span>
<span class="ln" data-ln="4"></span>
<span class="ln" data-ln="5">    // Relax all edges V-1 times</span>
<span class="ln" data-ln="6">    for i in range(1, V):</span>
<span class="ln" data-ln="7">        for each edge (u, v, w) in edges:</span>
<span class="ln" data-ln="8">            if dist[u] + w &lt; dist[v]:</span>
<span class="ln" data-ln="9">                dist[v] = dist[u] + w</span>
<span class="ln" data-ln="10"></span>
<span class="ln" data-ln="11">    // Check for negative-weight cycle</span>
<span class="ln" data-ln="12">    for each edge (u, v, w) in edges:</span>
<span class="ln" data-ln="13">        if dist[u] + w &lt; dist[v]:</span>
<span class="ln" data-ln="14">            print("Graph contains negative weight cycle")</span>
<span class="ln" data-ln="15">            return</span>
<span class="ln" data-ln="16"></span>
<span class="ln" data-ln="17">    return dist</span>
</code>
</pre>
    </div>
  </section>

  <!-- Distances section -->
  <section class="card distances-section">
    <h2>Distances (tentative)</h2>
    <div class="content">
      <div class="kv" id="distGrid" aria-live="polite"></div>
      <div class="note">Runs <b>V−1</b> full passes of relaxations, then a final pass to check for a <b>negative cycle</b>. Complexity: <code>O(VE)</code>.</div>
    </div>
  </section>
</div>

<script>
/* ===========================
   Sample directed graphs
=========================== */
const Samples = {
  base: { // no negative cycle
    nodes:['A','B','C','D','E','F','G'],
    pos:{
      A:[110,90], B:[260,80], C:[230,210], D:[410,130],
      E:[420,250], F:[260,340], G:[560,210]
    },
    edges:[ // (u,v,w)
      ['A','B', 6], ['A','C', 5], ['A','D', 5],
      ['B','E', -1], ['C','B', -2], ['C','E', 1],
      ['D','C', -2], ['D','F', -1],
      ['E','G', 3],  ['F','G', 3]
    ],
    source:'A'
  },
  negCycle: { // contains a negative cycle B -> D -> C -> B with total weight -1
    nodes:['A','B','C','D','E','F','G'],
    pos:{
      A:[110,90], B:[260,80], C:[230,210], D:[410,130],
      E:[420,250], F:[260,340], G:[560,210]
    },
    edges:[
      ['A','B', 4], ['A','C', 5],
      ['B','D', 1], ['D','C', -3], ['C','B', 1], // cycle weight: 1 + (-3) + 1 = -1
      ['C','E', 2], ['D','F', 2], ['E','G', 3], ['F','G', 4]
    ],
    source:'A'
  }
};

/* ===========================
   State
=========================== */
let G = JSON.parse(JSON.stringify(Samples.base));
const state = {
  source: G.source,
  dist: Object.create(null),
  prev: Object.create(null),
  iteration: 0,
  steps: [], stepIndex: 0, playing:false, speed:1.0,
  lastUpdated:null,
  negEdge:null, // [u,v] that triggers negative cycle
  treeEdges:new Set()
};

/* ===========================
   DOM elements
=========================== */
const svg = document.getElementById('graph');
const edgesBar = document.getElementById('edgesBar');
const distGrid = document.getElementById('distGrid');
const sourceSel = document.getElementById('sourceSel');
const btnPlay = document.getElementById('btnPlay');
const btnStep = document.getElementById('btnStep');
const btnReset = document.getElementById('btnReset');
const btnShuffle = document.getElementById('btnShuffle');
const btnLoadBase = document.getElementById('btnLoadBase');
const btnLoadNeg = document.getElementById('btnLoadNeg');
const btnShowPath = document.getElementById('btnShowPath');
const banner = document.getElementById('banner');
const speedRange = document.getElementById('speed');
const speedVal = document.getElementById('speedVal');

/* ===========================
   Helpers
=========================== */
function clear(el){while(el.firstChild) el.removeChild(el.firstChild);}
function setHL(lines){document.querySelectorAll('.ln').forEach(ln=>ln.classList.remove('hl')); (lines||[]).forEach(n=>{const el=document.querySelector(`.ln[data-ln="${n}"]`); if(el) el.classList.add('hl');});}
function formatDist(x){return (x===Infinity)?'∞':String(x);}
function edgeId(u,v){return `${u}->${v}`;}
function jitter(x,a,b){return Math.max(a, Math.min(b, x + (Math.random()*80-40)));}

/* ===========================
   Build SVG (directed)
=========================== */
function buildGraph(){
  clear(svg);

  // Arrowhead marker
  const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
  const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
  marker.setAttribute('id','arrow'); marker.setAttribute('orient','auto');
  marker.setAttribute('markerWidth','8'); marker.setAttribute('markerHeight','8'); marker.setAttribute('refX','7'); marker.setAttribute('refY','3.5');
  const tri = document.createElementNS('http://www.w3.org/2000/svg','path');
  tri.setAttribute('d','M0,0 L8,3.5 L0,7 Z'); tri.setAttribute('class','arrow');
  marker.appendChild(tri); defs.appendChild(marker); svg.appendChild(defs);

  // edges with labels
  for(const [u,v,w] of G.edges){
    const [x1,y1]=G.pos[u], [x2,y2]=G.pos[v];
    const dx=x2-x1, dy=y2-y1; const L=Math.hypot(dx,dy);
    const pad=20; const t=(L-pad)/L;
    const x2p=x1+dx*t, y2p=y1+dy*t;

    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1',x1); line.setAttribute('y1',y1);
    line.setAttribute('x2',x2p); line.setAttribute('y2',y2p);
    line.classList.add('edge'); line.dataset.u=u; line.dataset.v=v; line.dataset.w=w;
    line.setAttribute('marker-end','url(#arrow)');
    svg.appendChild(line);

    // label offset from midpoint
    const mx=(x1+x2)/2, my=(y1+y2)/2;
    const offx = (y2-y1)/12, offy = (x1-x2)/12;
    const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
    lbl.setAttribute('x', mx+offx); lbl.setAttribute('y', my+offy);
    lbl.setAttribute('text-anchor','middle'); lbl.classList.add('wlabel');
    lbl.textContent = w;
    lbl.dataset.u=u; lbl.dataset.v=v;
    if(w<0) lbl.style.fill = '#ffb8b8';
    svg.appendChild(lbl);
  }

  // nodes
  for(const id of G.nodes){
    const [x,y]=G.pos[id];
    const g=document.createElementNS('http://www.w3.org/2000/svg','g');
    g.classList.add('node'); g.dataset.id=id;
    g.setAttribute('tabindex','0'); g.setAttribute('role','button');
    g.setAttribute('aria-label',`Node ${id}. Click to set as source.`);
    g.addEventListener('click',()=>{ state.source=id; resetAll(); });

    const c=document.createElementNS('http://www.w3.org/2000/svg','circle');
    c.setAttribute('cx',x); c.setAttribute('cy',y); c.setAttribute('r',18);

    const t=document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x',x); t.setAttribute('y',y+5); t.setAttribute('text-anchor','middle'); t.textContent=id;

    g.appendChild(c); g.appendChild(t); svg.appendChild(g);
  }
}

function renderGraph(){
  // nodes
  document.querySelectorAll('.node').forEach(n=>{
    const id=n.dataset.id;
    n.classList.toggle('source', id===state.source);
    n.classList.toggle('updated', id===state.lastUpdated);
    n.classList.toggle('bad', state.negEdge && (id===state.negEdge[0] || id===state.negEdge[1]));
  });
  // edges + labels
  document.querySelectorAll('.edge').forEach(e=>{
    e.classList.remove('active','tree','bad');
    const u=e.dataset.u, v=e.dataset.v;
    if(state.activeEdge && state.activeEdge[0]===u && state.activeEdge[1]===v) e.classList.add('active');
    if(state.treeEdges.has(edgeId(u,v))) e.classList.add('tree');
    if(state.negEdge && state.negEdge[0]===u && state.negEdge[1]===v) e.classList.add('bad');
  });
  document.querySelectorAll('.wlabel').forEach(l=>{
    l.classList.remove('active','tree','bad');
    const u=l.dataset.u, v=l.dataset.v;
    if(state.activeEdge && state.activeEdge[0]===u && state.activeEdge[1]===v) l.classList.add('active');
    if(state.treeEdges.has(edgeId(u,v))) l.classList.add('tree');
    if(state.negEdge && state.negEdge[0]===u && state.negEdge[1]===v) l.classList.add('bad');
  });
}

function renderEdgesBar(){
  clear(edgesBar);
  G.edges.forEach(([u,v,w])=>{
    const d=document.createElement('div');
    d.className='chip';
    d.textContent=`${u}→${v} (${w})`;
    if(state.activeEdge && state.activeEdge[0]===u && state.activeEdge[1]===v) d.classList.add('active');
    if(state.lastUpdated===v) d.classList.add('upd');
    if(state.negEdge && state.negEdge[0]===u && state.negEdge[1]===v) d.classList.add('bad');
    edgesBar.appendChild(d);
  });
}

function renderDist(){
  clear(distGrid);
  G.nodes.forEach(n=>{
    const k=document.createElement('div'); k.className='key'; k.textContent=n;
    const v=document.createElement('div'); v.className='val'; v.textContent=formatDist(state.dist[n]);
    if(state.dist[n]===Infinity) v.classList.add('inf');
    if(state.lastUpdated===n) v.classList.add('upd');
    distGrid.appendChild(k); distGrid.appendChild(v);
  });
}

function renderAll(){
  renderGraph(); renderEdgesBar(); renderDist();
  if(state.stepIndex===0) setHL([1,2,3,5,6,7,8,9]);
}

/* ===========================
   Source dropdown
=========================== */
function populateSourceSel(){
  clear(sourceSel);
  G.nodes.forEach(n=>{ const o=document.createElement('option'); o.value=n; o.textContent=`Source: ${n}`; if(n===state.source) o.selected=true; sourceSel.appendChild(o); });
  sourceSel.addEventListener('change',()=>{ state.source=sourceSel.value; resetAll(); });
}

/* ===========================
   Step builder
=========================== */
function buildSteps(){
  const steps=[];
  const V = G.nodes.length;
  const dist = Object.fromEntries(G.nodes.map(n=>[n, Infinity]));
  const prev = Object.fromEntries(G.nodes.map(n=>[n, null]));

  steps.push({type:'init', hl:[1,2,3]});
  dist[state.source]=0;
  steps.push({type:'setSource', node:state.source, hl:[3]});

  // V-1 passes
  for(let i=1;i<=V-1;i++){
    steps.push({type:'passStart', i, hl:[5,6]});
    for(const [u,v,w] of G.edges){
      steps.push({type:'consider', u,v,w, i, hl:[7]});
      // only relax if u is reachable
      const alt = (dist[u]===Infinity) ? Infinity : dist[u]+w;
      steps.push({type:'check', u,v,w, alt, curr:dist[v], i, hl:[8]});
      if(alt < dist[v]){
        dist[v]=alt; prev[v]=u;
        steps.push({type:'relax', v, alt, prev:u, i, hl:[9]});
      }
    }
  }

  // negative cycle check
  steps.push({type:'cycleStart', hl:[11,12]});
  let foundCycle = false, badEdge=null;
  for(const [u,v,w] of G.edges){
    const alt = (dist[u]===Infinity) ? Infinity : dist[u]+w;
    steps.push({type:'cycleCheck', u,v,w, alt, curr:dist[v], hl:[13]});
    if(alt < dist[v] && !foundCycle){
      foundCycle = true; badEdge=[u,v];
      steps.push({type:'cycleFound', u,v, hl:[14,15]});
    }
  }
  steps.push({type:'done', dist, prev, badEdge, hl:[17]});
  state.steps = steps;
}

/* ===========================
   Apply steps
=========================== */
function applyStep(s){
  state.lastUpdated=null;
  switch(s.type){
    case 'init':
      state.iteration=0; state.treeEdges.clear();
      state.negEdge=null; state.activeEdge=null; banner.classList.remove('show');
      for(const n of G.nodes){ state.dist[n]=Infinity; state.prev[n]=null; }
      break;
    case 'setSource':
      state.dist[s.node]=0; state.lastUpdated=s.node;
      break;
    case 'passStart':
      state.iteration=s.i; state.activeEdge=null; break;
    case 'consider':
      state.activeEdge=[s.u,s.v]; break;
    case 'check':
      // only highlight; nothing to change
      break;
    case 'relax':
      state.dist[s.v]=s.alt; state.prev[s.v]=s.prev; state.lastUpdated=s.v;
      // update tree edges to reflect latest prev
      state.treeEdges.delete([...state.treeEdges].find(e=>e.endsWith('->'+s.v))||'');
      state.treeEdges.add(edgeId(s.prev, s.v));
      break;
    case 'cycleStart':
      state.activeEdge=null; break;
    case 'cycleCheck':
      state.activeEdge=[s.u,s.v]; break;
    case 'cycleFound':
      state.negEdge=[s.u,s.v]; banner.classList.add('show'); break;
    case 'done':
      state.activeEdge=null;
      state.treeEdges.clear();
      // rebuild tree edges from final prev map
      for(const n of G.nodes){
        const p = state.prev[n];
        if(p) state.treeEdges.add(edgeId(p,n));
      }
      if(s.badEdge){ state.negEdge=[...s.badEdge]; banner.classList.add('show'); }
      break;
  }
  setHL(s.hl||[]);
  renderAll();
}

/* ===========================
   Playback controls
=========================== */
let timer=null;
function stepOnce(){
  if(state.stepIndex>=state.steps.length){ pause(); return; }
  const st = state.steps[state.stepIndex++];
  applyStep(st);
}
function play(){ state.playing=true; btnPlay.textContent='⏸ Pause'; tick(); }
function pause(){ state.playing=false; btnPlay.textContent='▶ Play'; if(timer) clearTimeout(timer); }
function tick(){ if(!state.playing) return; stepOnce(); const base=600; timer=setTimeout(tick, base/state.speed); }

/* ===========================
   UI wiring
=========================== */
btnPlay.addEventListener('click',()=>{ state.playing?pause():play(); });
btnStep.addEventListener('click',()=>{ pause(); stepOnce(); });
btnReset.addEventListener('click',()=>{ pause(); resetAll(); });
btnShuffle.addEventListener('click',()=>{
  for(const id of G.nodes){
    const [x0,y0]=G.pos[id];
    G.pos[id]=[jitter(x0,60,740), jitter(y0,60,460)];
  }
  buildGraph(); renderAll();
});
btnLoadBase.addEventListener('click',()=>{ pause(); loadSample('base'); });
btnLoadNeg.addEventListener('click',()=>{ pause(); loadSample('negCycle'); });
btnShowPath.addEventListener('click',()=>{
  // highlight a path from a chosen target back to source via prev
  // choose target: lastUpdated or farthest finite distance
  let target = state.lastUpdated || null;
  if(!target){
    let best=null,bv=-1;
    for(const n of G.nodes){ const d=state.dist[n]; if(isFinite(d) && d>bv){ bv=d; best=n; } }
    target = best || state.source;
  }
  state.treeEdges.clear();
  let cur=target;
  const safety=G.nodes.length+5;
  let k=0;
  while(cur && cur!==state.source && k++<safety){
    const p = state.prev[cur]; if(!p) break;
    state.treeEdges.add(edgeId(p,cur)); cur=p;
  }
  renderAll();
});

speedRange.addEventListener('input',()=>{ state.speed=parseFloat(speedRange.value); speedVal.textContent=state.speed.toFixed(1); });

document.addEventListener('keydown',(e)=>{
  if(e.key===' '){ e.preventDefault(); btnPlay.click(); }
  else if(e.key.toLowerCase()==='n'){ e.preventDefault(); btnStep.click(); }
  else if(e.key.toLowerCase()==='r'){ e.preventDefault(); btnReset.click(); }
});

/* ===========================
   Reset & Bootstrap
=========================== */
function resetAll(){
  state.stepIndex=0; banner.classList.remove('show');
  buildSteps(); renderAll(); setHL([1,2,3,5,6]);
}
function loadSample(name){
  G = JSON.parse(JSON.stringify(Samples[name]));
  state.source = G.source;
  populateSourceSel(); buildGraph(); resetAll();
}
function init(){
  populateSourceSel();
  buildGraph();
  resetAll();
}
init();
</script>
</body>
</html>
