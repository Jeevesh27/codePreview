<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Kruskal’s Algorithm Visualizer</title>
<style>
  :root{
    --bg:#0f1220; --panel:#161a2d; --panel-2:#1e2340;
    --accent:#6cf3ff; --accent-2:#8ae9c1;
    --text:#ecf2ff; --muted:#a6b0cf;
    --ok:#84fab0; --slot:#2a305a; --chip:#39407a;
    --shadow:0 10px 30px rgba(0,0,0,.35);
    --radius:16px; --gap:14px; --speed:300ms;
    --pair:#ffd166; /* yellow for selected terms */
    --new:#8ae9c1;  /* green for newly added term */
  }

  * { box-sizing: border-box; }
  body{
    margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
    background: radial-gradient(1000px 600px at 80% -10%, #1a1f3a 0%, #0f1220 50%) no-repeat, var(--bg);
    color: var(--text);
  }

  header{
    padding: 24px clamp(16px, 4vw, 32px);
    display: flex; align-items: center; justify-content: space-between;
    gap: 16px;
  }
  .title h1{ margin:0; font-size: clamp(22px, 2.2vw, 30px); letter-spacing: .3px;}
  .subtitle{ color: var(--muted); margin-top:6px; font-size: 0.95rem;}
  .controls{
    display:flex; gap:10px; flex-wrap:wrap;
  }
  button{
    background: linear-gradient(180deg, var(--panel-2), var(--panel));
    color: var(--text); border: 1px solid #222842;
    padding: 10px 14px; border-radius: 10px; cursor: pointer;
    box-shadow: var(--shadow);
    transition: transform .08s ease, background var(--speed), border-color var(--speed);
    font-weight: 600;
  }
  button:hover{ transform: translateY(-1px); border-color:#2c3256;}
  button:active{ transform: translateY(0); }
  button[aria-pressed="true"]{ outline: 2px solid var(--accent); }
  .chip{
    background: var(--chip); color: var(--text); padding:4px 8px; border-radius: 999px; border:1px solid #2a2f58; font-size: 12px;
  }

  main{
    padding: 0 clamp(16px, 4vw, 32px) 32px;
    display: grid;
    grid-template-columns: 1.2fr .9fr;
    gap: clamp(14px, 2vw, 20px);
  }
  @media (max-width: 980px){
    main{ grid-template-columns: 1fr; }
  }

  .panel{
    background: linear-gradient(180deg, var(--panel-2), var(--panel));
    border:1px solid #20264a; border-radius: var(--radius); box-shadow: var(--shadow);
    overflow: clip;
  }
  .panel header{
    padding: 12px 16px; background: #141832; border-bottom: 1px solid #1f2546;
  }
  .panel header h2{ margin:0; font-size: 16px; letter-spacing:.5px; }
  .panel .content{ padding: 14px; }

  /* Graph area */
  .graph-wrap{
    position: relative; aspect-ratio: 16/10; width: 100%;
    background:
      radial-gradient(600px 200px at 70% -20%, rgba(108,243,255,.10), transparent 60%),
      linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0));
    border-bottom-left-radius: var(--radius); border-bottom-right-radius: var(--radius);
  }
  svg{ width: 100%; height: 100%; display:block; }

  .edge { stroke: #515a93; stroke-width: 3; opacity:.85; transition: all var(--speed); }
  .edge-hover { stroke: #7e88c7; }
  .edge-label{
    font-size: 12px; fill: var(--muted); user-select:none; paint-order: stroke; stroke: #0d1125; stroke-width: 3px;
  }
  .edge.mst { stroke: var(--new); stroke-width: 5; filter: drop-shadow(0 0 4px rgba(138,233,193,.65)); }
  .edge.considered { stroke: var(--pair); stroke-width: 5; }
  .edge.rejected { stroke: #b05a7a; stroke-dasharray: 8 6; opacity:.9; }

  .node{ fill: #1d2350; stroke: #2e3a7d; stroke-width: 2; transition: transform var(--speed); }
  .node text{ fill: var(--text); font-weight: 700; font-size: 12px; }
  .node circle{ r: 16; }
  .node.mst circle{ fill: #203a3a; stroke: var(--new); }
  .node:hover{ filter: drop-shadow(0 0 6px rgba(108, 243, 255, .5)); }

  /* Edge list + DSU */
  .edge-list, .dsu{
    display: grid; gap:10px;
  }
  .edge-item{
    display:grid; grid-template-columns: 48px 1fr 60px; align-items:center; gap:8px;
    padding:10px; border-radius:12px; background: var(--slot); border:1px solid #2a2f58;
  }
  .edge-item .badge{
    width:40px; height:40px; display:grid; place-items:center; border-radius:10px; background: var(--chip);
    font-weight:700;
  }
  .edge-item .uv{ color: var(--text); font-weight:600; }
  .edge-item .w{ text-align:right; color: var(--accent-2); font-weight:700; }
  .edge-item.active{ outline:2px solid var(--pair); }
  .edge-item.accepted{ outline:2px solid var(--new); background: #1f2c2a; }
  .edge-item.rejected{ opacity:.7; background: #2b1e2a; }

  .dsu-grid{
    display:grid; grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap:10px;
  }
  .dsu-card{
    background: var(--slot); border:1px solid #2a2f58; border-radius: 12px; padding:10px;
  }
  .dsu-card .root{
    font-weight:800; color: var(--accent);
  }
  .mini{
    font-size: 12px; color: var(--muted); margin-top:6px; line-height:1.3;
  }

  .legend{
    display:flex; gap:8px; flex-wrap:wrap; align-items:center;
  }
  .legend .chip{ display:inline-flex; gap:6px; align-items:center; }
  .swatch{ width:10px; height:10px; border-radius:2px; display:inline-block; }
  .swatch.mst{ background: var(--new); }
  .swatch.considered{ background: var(--pair); }
  .swatch.rejected{ background: #b05a7a; }

  .explain{
    background: #101433; border-top:1px solid #1f2546; padding:12px 14px; color: var(--text);
  }
  .explain b{ color: var(--accent); }
  .kbd{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; background:#0e1230; border:1px solid #1c2250; padding:2px 6px; border-radius:8px; }
</style>
</head>
<body>
  <header>
    <div class="title">
      <h1>🔗 Kruskal’s Algorithm</h1>
      <div class="subtitle">Greedy: sort edges by weight, add if they don’t form a cycle — using <b>Disjoint Set Union (Union-Find)</b>. Time: <span class="chip">O(E log E)</span></div>
    </div>
    <div class="controls" role="group" aria-label="Playback">
      <button id="btn-play" aria-label="Play/Pause (Space)">▶ Play</button>
      <button id="btn-step" aria-label="Step (N)">Step ▷</button>
      <button id="btn-reset" aria-label="Reset (R)">Reset ↺</button>
      <button id="btn-shuffle" aria-label="Shuffle Weights (S)">Shuffle Weights 🎲</button>
    </div>
  </header>

  <main>
    <!-- Left: Graph -->
    <section class="panel">
      <header>
        <h2>Graph</h2>
      </header>
      <div class="content graph-wrap">
        <svg id="graph" viewBox="0 0 800 520" aria-labelledby="graph-title" role="img">
          <title id="graph-title">Graph visualization for Kruskal’s Algorithm</title>
          <g id="edges"></g>
          <g id="nodes"></g>
        </svg>
      </div>
      <div class="explain" id="explain">Ready. Press <span class="kbd">Play</span> or <span class="kbd">Step</span> to begin.</div>
    </section>

    <!-- Right: Edge order + DSU -->
    <section class="panel">
      <header>
        <h2>Sorted Edges &amp; DSU</h2>
      </header>
      <div class="content">
        <div class="legend" style="margin-bottom:10px">
          <span class="chip"><span class="swatch considered"></span> considered</span>
          <span class="chip"><span class="swatch mst"></span> accepted</span>
          <span class="chip"><span class="swatch rejected"></span> rejected</span>
        </div>

        <h3 style="margin:8px 0 8px">Edges (ascending weight)</h3>
        <div class="edge-list" id="edge-list" aria-live="polite"></div>

        <h3 style="margin:14px 0 8px">Union–Find (DSU)</h3>
        <div class="dsu" id="dsu"></div>
        <p class="mini">Each set represents a connected component. We use <b>path compression</b> &amp; <b>union by rank</b>.</p>
      </div>
    </section>
  </main>

<script type="module">
/* -------------------------
   Utility & Data
-------------------------- */
const svg = document.getElementById('graph');
const gEdges = document.getElementById('edges');
const gNodes = document.getElementById('nodes');
const edgeListEl = document.getElementById('edge-list');
const dsuEl = document.getElementById('dsu');
const explainEl = document.getElementById('explain');

const BTN = {
  play: document.getElementById('btn-play'),
  step: document.getElementById('btn-step'),
  reset: document.getElementById('btn-reset'),
  shuffle: document.getElementById('btn-shuffle'),
};

const STATE = {
  nodes: [],
  edges: [],
  sorted: [],
  i: 0,
  running: false,
  timer: null,
  mstEdges: [],
  n: 8
};

function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

/* Positions for 8 nodes arranged nicely */
function defaultNodes(n=8){
  const cx = 400, cy = 250, R = 190;
  return Array.from({length:n}, (_,i)=>{
    const ang = (i / n) * Math.PI*2 - Math.PI/2;
    return { id:i, x: Math.round(cx + R*Math.cos(ang)), y: Math.round(cy + R*Math.sin(ang)) };
  });
}

/* A pleasant connected base graph (edges + weights), then we’ll shuffle weights */
function baseEdges(){
  // Some hand-picked connections (undirected)
  const E = [
    [0,1,7],[1,2,5],[2,3,8],[3,4,10],[4,5,3],[5,6,6],[6,7,4],[7,0,9],
    [0,2,9],[1,3,7],[2,4,2],[3,5,4],[4,6,5],[5,7,1],[6,0,6],[7,2,3]
  ];
  return E.map(([u,v,w], id)=>({id, u, v, w}));
}

function shuffleWeights(edges){
  return edges.map(e=>({...e, w: randInt(1, 12)}));
}

/* -------------------------
   DSU (Union-Find)
-------------------------- */
class DSU{
  constructor(n){
    this.parent = Array.from({length:n}, (_,i)=>i);
    this.rank = Array.from({length:n}, _=>0);
  }
  find(x){
    if (this.parent[x] !== x) this.parent[x] = this.find(this.parent[x]);
    return this.parent[x];
  }
  union(a,b){
    let ra = this.find(a), rb = this.find(b);
    if (ra === rb) return false;
    if (this.rank[ra] < this.rank[rb]) [ra, rb] = [rb, ra];
    this.parent[rb] = ra;
    if (this.rank[ra] === this.rank[rb]) this.rank[ra]++;
    return true;
  }
  sets(){
    const groups = new Map();
    for(let i=0;i<this.parent.length;i++){
      const r = this.find(i);
      if(!groups.has(r)) groups.set(r, []);
      groups.get(r).push(i);
    }
    return [...groups.entries()].map(([root, members])=>({root, members}));
  }
}

/* -------------------------
   Render: Nodes & Edges
-------------------------- */
function renderNodes(){
  gNodes.innerHTML = '';
  STATE.nodes.forEach(n=>{
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('class','node');
    g.setAttribute('transform',`translate(${n.x},${n.y})`);
    g.innerHTML = `
      <circle></circle>
      <text text-anchor="middle" dy="4">${n.id}</text>
    `;
    gNodes.appendChild(g);
  });
}

function edgeKey(u,v){ return u < v ? `${u}-${v}` : `${v}-${u}`; }

function renderEdges(){
  gEdges.innerHTML = '';
  STATE.edges.forEach(e=>{
    const n1 = STATE.nodes[e.u], n2 = STATE.nodes[e.v];
    const midx = (n1.x+n2.x)/2, midy = (n1.y+n2.y)/2;

    const path = document.createElementNS('http://www.w3.org/2000/svg','line');
    path.setAttribute('x1', n1.x); path.setAttribute('y1', n1.y);
    path.setAttribute('x2', n2.x); path.setAttribute('y2', n2.y);
    path.setAttribute('class', 'edge');
    path.dataset.key = edgeKey(e.u,e.v);
    gEdges.appendChild(path);

    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
    label.setAttribute('x', midx); label.setAttribute('y', midy - 6);
    label.setAttribute('class', 'edge-label');
    label.textContent = e.w;
    gEdges.appendChild(label);
  });
}

/* Edge styles according to state */
function markEdge(key, status){
  const line = [...gEdges.querySelectorAll('.edge')].find(el=>el.dataset.key===key);
  if(!line) return;
  line.classList.remove('considered','mst','rejected');
  if(status) line.classList.add(status);
}

/* -------------------------
   Edge List & DSU Panels
-------------------------- */
function renderEdgeList(){
  edgeListEl.innerHTML = '';
  STATE.sorted.forEach((e,idx)=>{
    const div = document.createElement('div');
    div.className = 'edge-item';
    div.id = `edge-item-${e.id}`;
    div.innerHTML = `
      <div class="badge">${idx+1}</div>
      <div class="uv">(${e.u} — ${e.v})</div>
      <div class="w">w=${e.w}</div>
    `;
    edgeListEl.appendChild(div);
  });
}

function highlightEdgeItem(eid, status){
  const el = document.getElementById(`edge-item-${eid}`);
  if(!el) return;
  el.classList.remove('active','accepted','rejected');
  if(status) el.classList.add(status);
}

function renderDSU(dsu){
  dsuEl.innerHTML = '';
  const grid = document.createElement('div');
  grid.className = 'dsu-grid';
  dsu.sets().forEach(set=>{
    const card = document.createElement('div');
    card.className = 'dsu-card';
    card.innerHTML = `
      <div>Root: <span class="root">${set.root}</span></div>
      <div>Members: ${set.members.join(', ')}</div>
    `;
    grid.appendChild(card);
  });
  dsuEl.appendChild(grid);
}

/* -------------------------
   Algorithm Playback
-------------------------- */
let dsu;

function init(shuffle=false){
  STATE.nodes = defaultNodes(STATE.n);
  const base = baseEdges();
  STATE.edges = shuffle ? shuffleWeights(base) : base;
  STATE.sorted = [...STATE.edges].sort((a,b)=>a.w-b.w || a.id-b.id);
  STATE.i = 0;
  STATE.running = false;
  STATE.mstEdges = [];
  clearTimeout(STATE.timer); STATE.timer = null;
  BTN.play.textContent = '▶ Play';
  BTN.play.setAttribute('aria-pressed','false');
  dsu = new DSU(STATE.n);
  renderNodes(); renderEdges(); renderEdgeList(); renderDSU(dsu);
  explain('Ready. The edges above are sorted by weight. Kruskal will scan them in order.');
  // Clear styles
  STATE.edges.forEach(e=>{
    markEdge(edgeKey(e.u,e.v), null);
    highlightEdgeItem(e.id, null);
  });
}

function explain(text){
  explainEl.innerHTML = text;
}

function step(){
  if (STATE.i >= STATE.sorted.length){
    explain(`<b>Done.</b> No more edges to consider. The highlighted green edges form the <b>Minimum Spanning Tree</b>.`);
    return false;
  }
  const e = STATE.sorted[STATE.i];
  const key = edgeKey(e.u, e.v);

  // Consider edge
  markEdge(key, 'considered');
  highlightEdgeItem(e.id, 'active');
  explain(`Considering edge <b>(${e.u}, ${e.v})</b> with weight <b>${e.w}</b>.<br>
           Check DSU parents: find(${e.u}) = <b>${dsu.find(e.u)}</b>, find(${e.v}) = <b>${dsu.find(e.v)}</b>.`);

  // Decision after a short pause for visual effect
  setTimeout(()=>{
    const diff = dsu.find(e.u) !== dsu.find(e.v);
    if (diff){
      dsu.union(e.u, e.v);
      STATE.mstEdges.push(e);
      markEdge(key, 'mst');
      gNodes.querySelectorAll('.node').forEach((nd,i)=>{
        if(dsu.find(i) === dsu.find(e.u) || dsu.find(i) === dsu.find(e.v)){
          nd.classList.add('mst');
        }
      });
      highlightEdgeItem(e.id, 'accepted');
      renderDSU(dsu);
      explain(`Accepted edge <b>(${e.u}, ${e.v})</b> — they were in different sets, so adding it does <b>not</b> form a cycle. <span class="chip">union(${e.u}, ${e.v})</span>`);
    } else {
      markEdge(key, 'rejected');
      highlightEdgeItem(e.id, 'rejected');
      explain(`Rejected edge <b>(${e.u}, ${e.v})</b> — both endpoints are already in the same set, which would form a <b>cycle</b>.`);
    }
    STATE.i++;
  }, 300);

  return true;
}

function play(){
  if (STATE.running){
    STATE.running = false; BTN.play.textContent = '▶ Play';
    BTN.play.setAttribute('aria-pressed','false');
    clearTimeout(STATE.timer); STATE.timer=null;
    return;
  }
  STATE.running = true; BTN.play.textContent = '⏸ Pause';
  BTN.play.setAttribute('aria-pressed','true');
  const tick = ()=>{
    if (!STATE.running) return;
    const more = step();
    if (!more){ STATE.running=false; BTN.play.textContent='▶ Play'; BTN.play.setAttribute('aria-pressed','false'); return; }
    STATE.timer = setTimeout(tick, 1200);
  };
  tick();
}

/* -------------------------
   Wire up Controls & Keys
-------------------------- */
BTN.play.addEventListener('click', play);
BTN.step.addEventListener('click', ()=>{ if(STATE.running) play(); step(); });
BTN.reset.addEventListener('click', ()=> init(false));
BTN.shuffle.addEventListener('click', ()=> init(true));

window.addEventListener('keydown', (e)=>{
  if (e.key === ' '){ e.preventDefault(); play(); }
  if (e.key.toLowerCase() === 'n'){ step(); }
  if (e.key.toLowerCase() === 'r'){ init(false); }
  if (e.key.toLowerCase() === 's'){ init(true); }
});

/* Hover affordance on edges */
gEdges.addEventListener('pointerover', (e)=>{
  if (e.target.classList.contains('edge')) e.target.classList.add('edge-hover');
});
gEdges.addEventListener('pointerout', (e)=>{
  if (e.target.classList.contains('edge')) e.target.classList.remove('edge-hover');
});

/* -------------------------
   Bootstrap
-------------------------- */
init(false);

/* -------------------------
   FYI: The algorithm (reference)
-------------------------- */
/*
function Kruskal(V, edges):
    sort edges by weight
    initialize DSU for V vertices
    MST = empty set
    for each (u, v, w) in edges (in sorted order):
        if find(u) != find(v):   // different sets → no cycle
            union(u, v)
            add (u, v, w) to MST
    return MST
*/
</script>
</body>
</html>
